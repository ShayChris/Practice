## 简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？


### 脏读
一个事务处理处理过程中读到了另一个未提交的事务的数据。

### 幻读
事务非独立执行时发生的一种现象。例：事务A将表中所有数据的一列由1更新成2，这时候时候B将一条1的数据插入表中，
然后事务A再去查询表发现仍然存在为1的数据，就像发生了幻觉一样。和不可重复读都是读取了另一条已经提交的事务，区别是不可重复读查询的是同一个数据项，而幻读是针对一批数据。

### InnoDB是如何解决幻读的？
在Repeatable Read的隔离级别下，InnoDB使用MVVC和next-key locks解决幻读，MVCC解决的是普通读（快照读）的幻读，
next-key locks解决的是当前读情况下的幻读。
#### 当前读
所谓当前读，指的是加锁的select，update，delete等语句。在Repeatable Read的事务隔离级别下，数据库会使用next-key locks来锁定本条记录以及索引区间。
select * from table where id > 3 会锁住id>3这个区间范围，避免范围间插入记录，以避免产生幻影行记录。
#### 普通读
普通读是不会加锁的读，解决幻读是用MVVC。  
MVVC会给每条数据多加一些辅助字段，记录创建版本号和删除版本号。  
每一个事务启动的时候，都有一个唯一递增的版本号。每开启一个新事务，事务的版本号就会递增。  
默认的RR隔离级别下，增删改查就会变成下面这样：
select：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前的记录是存在的。
insert：将当前事务的版本号保存至数据行的创建版本号  
update：新插入一行，并以当前事务的版本作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号  
delete：将当前事务的版本号保存至行的删除版本号  
