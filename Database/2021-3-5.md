## 简述乐观锁以及悲观锁的区别以及使用场景

### 悲观锁
定义：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以在每次拿数据的时候都会上锁，这样别人想拿到这个数据就会阻塞直到它拿到锁，
共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程
使用场景：多写的情况下，容易产生冲突，一般用悲观锁比较合适
实现方式：行锁，表锁，排它锁等等，Java中的synchronized和ReentrantLock


### 乐观锁
定义：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁
使用场景：多读少写的情况，可以提高吞吐量  
实现方式：1.版本号机制  
数据表维护一个数据版本号字段，表示数据被修改的次数，当数据被修改时，版本号加1，在读取数据的同时也会读取版本号，
在提交更新的时候会对比当前版本号和读取到的版本号，相等时才更新，否则重试更新操作  
2.CAS算法
compare and swap（比较与交换）算法，CAS算法涉及以下三个操作数：需要读取的内存值V、进行比较的值A、要写入的新值B  
只有当V=A时，才用B去更新V值，否则不执行任何操作，一般情况下是自旋，不断的重试  
缺点：1.ABA问题，当一个值从A变成B又变成A，CAS会误认为它从来没被修改过。AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。  
2.循环时间开销大，CAS的自旋操作长时间不成功，会给CPU带来很大的执行开销  
3.只能保证单个共享变量有效，当涉及跨多个共享变量时CAS无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。