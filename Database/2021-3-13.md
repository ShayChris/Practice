## Redis 如何实现延时队列，分布式锁的实现原理

### 实现延时队列
可以通过Redis的zset来实现。将消息序列化成一个字符串作为zset的value，这个消息的到期处理时间作为score，然后用多个
线程轮询zset获取到期的任务进行处理，多个线程是为了保证可用性，通过rem保证唯一的属主。

### 分布式锁实现原理
#### 第一版 setnx
向 Redis 中添加一个 lockKey 锁标志位, 如果添加成功则能够继续向下执行操作, 最后再释放此标志位  
#### 第二版 expire
上面第一版基于 setnx 命令实现分布式锁的缺陷也是很明显的, 那就是一定情况下可能发生死锁，如果方法执行异常导致的线程被回收, 
那么可以将解锁操作放到finally块中但是还有存在死锁问题, 如果获得锁的线程在执行中, 服务被强制停止或服务器宕机, 锁依然不会得到释放。   
这种极端情况下我们还是要考虑的, 毕竟不能只想着服务没问题对吧，对Redis的锁标志位加上过期时间 就能很好的防止死锁问题
但依然无法避免极端情况下的死锁问题，那就是如果在客户端加锁成功后, 还没有设置过期时间时宕机。  
如果想要避免添加锁时死锁, 那就对添加锁标志位 & 添加过期时间命令 保证一个原子性, 要么一起成功, 要么一起失败。
#### 第三版 set
我们的添加锁原子命令就要登场了, 从 Redis 2.6.12 版本起, 提供了可选的字符串set复合命令  
SET key value [expiration EX seconds|PX milliseconds] [NX|XX]  
可选参数如下:  
EX: 设置超时时间，单位是秒  
PX: 设置超时时间，单位是毫秒  
NX: IF NOT EXIST 的缩写，只有 KEY不存在的前提下 才会设置值  
XX: IF EXIST 的缩写，只有在 KEY存在的前提下 才会设置值  
加锁以及设置过期时间确实保证了原子性, 但是这样的分布式锁任然存在问题。  
1、线程一获取锁成功, 设置过期时间五秒, 接着执行业务逻辑。
2、接着线程一获取锁后执行业务流程, 执行的时间超过了过期时间, 锁标志位过期进行释放, 此时线程二获取锁成功。
3、然而此时线程一执行完业务后, 开始执行释放锁的流程, 然后顺手就把线程二获取的锁释放了。  
如果线上真的发生上述问题, 那真的是xxx, 更甚者可能存在线程一将线程二的锁释放掉之后, 线程三获取到锁, 然后线程二执行完将线程三的锁释放。  
#### 第四版 verify value
创建辨别客户端身份的唯一值了, 将加锁及解锁归一化。  
添加锁标志位时, 同时为每个客户端设置了 uuid 作为锁标志位的 val, 解锁时需要判断锁的 val 是否和自己客户端的相同, 辨别成功才会释放锁。  
但是解锁时, 由于判断锁和删除标志位并不是原子性的, 所以可能还是会存在误删  
1、线程一获取锁后, 执行流程，判断锁也是自家的, 这时 CPU 转头去做别的事情了, 恰巧线程一的锁过期时间到了
2、线程二此时顺理成章的获取到了分布式锁, 执行业务逻辑
3、线程一再次分配到时间片继续执行删除操作  
解决这种非原子操作的方式只能 将判断元素值和删除标志位当作一个原子操作
#### 第五版 lua
del 删除操作并没有提供原子命令,所以我们需要使用别的方法  
Redis在 2.6 推出了脚本功能, 允许开发者使用 Lua 语言编写脚本传到 Redis 中执行  
1、减少网络开销  
原本我们需要向 Redis 服务请求多次命令, 可以将命令写在 Lua 脚本中, 这样执行只会发起一次网络请求  
2、原子操作  
Redis 会将 Lua 脚本中的命令当作一个整体执行, 中间不会插入其它命令

