## 数据库的事务隔离级别有哪些？各有哪些优缺点？

脏读：一个事务处理过程中读到了另一个未提交的事务的数据。  
不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，原因是在查询间隔，被另一个事务修改并提交了  
幻读：事务非独立执行时发生的一种现象。例：事务T1将表中所有数据的某一列从1修改为2，这时事务T2又将一条数据为1的数据插入表中，
当事务T1再去查看表数据时，就好像产生了幻觉一样。幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读查询的
都是同一个数据项，而幻读针对的是一批数据整体。

### 修改隔离级别的语句
SET [作用域] TRANSACTION ISOLATION LEVEL [事务隔离级别]  
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}

### 数据库事务隔离级别及其优缺点
1.Serializable（串行化）
优点：可避免脏读、不可重复读、幻读的发生  
缺点：相当于单线程，并发性能最差，基本不用    
2.Repeatable read（可重复读）  
优点：可避免脏读、不可重复读的发生  
缺点：无法避免幻读的发生
3.Read committed（读已提交）  
优点：可避免脏读的发生  
缺点：不可避免可重复读，幻读的发生
4.Read uncommitted（读未提交）  
优点：不加锁，性能最好  
缺点：事务的隔离性最差，任何情况都无法保证，基本不用

### 数据库事务隔离级别的实现方式
1.Serializable（串行化）  
读：加共享锁，允许其他事务同时读  
写：加排它锁，不允许其他事务读写  
2.Repeatable read（可重复读）  
读：MVVC版本控制，一行记录有多个版本，每条记录加上了一个表示版本的字段，这个字段就是当前事务的id，按时间顺序地址，在事务开始时，
生成一个当前事务的全局性快照，这个快照读到的版本数据遵循以下规则：
1.当前事务内更新，可以读取到2.版本未提交，不能读取到3.版本已提交，在快照创建前能读取到，在快照创建后不能读取到  
写：加行锁，当前事务提交后才会释放。有索引直接在索引树中找到这行数据加行锁，无索引直接所有行加行锁，不满足的行就释放锁，最终只留下符合条件的  
3.Read committed（读已提交）  
读：跟可重复读的区别是，可重复读是当前事务开始时生成一个全局性快照，它是每有一次提交都会生成一次快照  
写：同上  
4.Read uncommitted（读未提交）
读：不加锁  
写：不加锁  
