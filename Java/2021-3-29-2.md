## JVM 中内存模型是怎样的，简述新生代与老年代的区别？
### JVM内存模型
- 堆：线程共享，所有对象实例和数据都要在堆上分配，垃圾回收器主要管理的对象
- 方法区：线程共享，保存类信息，常量，静态变量，以及即时编译的代码
- 方法栈：线程私有，存储局部变量表，操作数栈，动态链接，方法出口，对象指针
- 本地方法栈：线程私有，类似方法栈，但是调用的是native方法，底层由C或者C++编写
- 程序计数器：线程私有，当前线程所指向的字节码的指示器，指向下一条要执行的命令
### 新生代和老年代的区别
#### 新生代
主要是用来存放新生的对象，一般占据堆空间的1/3，由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。
分为Eden区、ServivorFrom、ServivorTo三个区。
- Eden区：Java新对象的出生地（如果新创建的对象占用内存很大则直接分配给老年代）。当Eden区内存不够的时候就会触发一次MinorGC，对新生代区进行一次垃圾回收。
- ServivorTo：保留了一次MinorGC过程中的幸存者。
- ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。
当JVM无法为新创建对象分配内存空间的时候（Eden区满的时候），JVM触发MinorGC。因此新生代空间占用越低，MinorGC越频繁。MinorGC使用复制算法。
新生代对象每存活下来一次，年龄+1，默认达到15时会被放入老年代。
  
#### 老年代
年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。
年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。