## volatile 关键字解决了什么问题，它的实现原理是什么？
### 解决问题
volatile实现了Java内存模型中的可见性和有序性。  
可见性：线程之间的可见性，一个线程修改的状态对另一个线程是可见的。volatile修饰的变量不允许线程内部缓存和重排序，则直接修改内存。  
有序性：保证了线程之间操作的有序性，因为volatile本身包含禁止指令重排序的语义。
### 原理
1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。  
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；
（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。
